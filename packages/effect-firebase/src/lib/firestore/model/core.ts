import { Schema } from 'effect';
import type { Brand } from 'effect/Brand';
import { VariantSchema } from '@effect/experimental';

// TODO: Keep an eye on the progress of Effect v4 Models as they intend to be more agnostic to the database and more flexible.
// Everything below are ports of Model from @effect/sql to prevent issues with types being out of sync.

export const {
  Class,
  Field,
  FieldExcept,
  FieldOnly,
  Struct,
  Union,
  extract,
  fieldEvolve,
  fieldFromKey,
} = VariantSchema.make({
  variants: ['get', 'add', 'update', 'json', 'jsonAdd', 'jsonUpdate'],
  defaultVariant: 'get',
});

export type Any = Schema.Schema.Any & {
  readonly fields: Schema.Struct.Fields;
  readonly add: Schema.Schema.Any;
  readonly update: Schema.Schema.Any;
  readonly json: Schema.Schema.Any;
  readonly jsonAdd: Schema.Schema.Any;
  readonly jsonUpdate: Schema.Schema.Any;
};

export type AnyNoContext = Schema.Schema.AnyNoContext & {
  readonly fields: Schema.Struct.Fields;
  readonly add: Schema.Schema.AnyNoContext;
  readonly update: Schema.Schema.AnyNoContext;
  readonly json: Schema.Schema.AnyNoContext;
  readonly jsonAdd: Schema.Schema.AnyNoContext;
  readonly jsonUpdate: Schema.Schema.AnyNoContext;
};

export type VariantsDatabase = 'get' | 'add' | 'update';
export type VariantsJson = 'json' | 'jsonAdd' | 'jsonUpdate';

export const fields: <A extends VariantSchema.Struct<any>>(
  self: A
) => A[VariantSchema.TypeId] = VariantSchema.fields;
export const Override: <A>(value: A) => A & Brand<'Override'> =
  VariantSchema.Override;

export type Generated<
  S extends Schema.Schema.All | Schema.PropertySignature.All
> = VariantSchema.Field<{
  readonly get: S;
  readonly update: S;
  readonly json: S;
}>;

/**
 * A field that represents a column that is generated by the database.
 *
 * It is available for selection and update, but not for insertion.
 */
export const Generated = <
  S extends Schema.Schema.All | Schema.PropertySignature.All
>(
  schema: S
): Generated<S> =>
  Field({
    get: schema,
    update: schema,
    json: schema,
  });

export type GeneratedByApp<
  S extends Schema.Schema.All | Schema.PropertySignature.All
> = VariantSchema.Field<{
  readonly get: S;
  readonly add: S;
  readonly update: S;
  readonly json: S;
}>;

/**
 * A field that represents a column that is generated by the application.
 *
 * It is required by the database, but not by the JSON variants.
 */
export const GeneratedByApp = <
  S extends Schema.Schema.All | Schema.PropertySignature.All
>(
  schema: S
): GeneratedByApp<S> =>
  Field({
    get: schema,
    add: schema,
    update: schema,
    json: schema,
  });

export type Sensitive<
  S extends Schema.Schema.All | Schema.PropertySignature.All
> = VariantSchema.Field<{
  readonly get: S;
  readonly add: S;
  readonly update: S;
}>;

/**
 * A field that represents a sensitive value that should not be exposed in the
 * JSON variants.
 */
export const Sensitive = <
  S extends Schema.Schema.All | Schema.PropertySignature.All
>(
  schema: S
): Sensitive<S> =>
  Field({
    get: schema,
    add: schema,
    update: schema,
  });

/**
 * Convert a field to one that is optional for all variants.
 *
 * For the database variants, it will accept `null`able values.
 * For the JSON variants, it will also accept missing keys.
 */
export type FieldOption<S extends Schema.Schema.Any> = VariantSchema.Field<{
  readonly get: Schema.OptionFromNullOr<S>;
  readonly add: Schema.OptionFromNullOr<S>;
  readonly update: Schema.OptionFromNullOr<S>;
  readonly json: Schema.optionalWith<S, { as: 'Option' }>;
  readonly jsonAdd: Schema.optionalWith<S, { as: 'Option'; nullable: true }>;
  readonly jsonUpdate: Schema.optionalWith<S, { as: 'Option'; nullable: true }>;
}>;

/**
 * Convert a field to one that is optional for all variants.
 *
 * For the database variants, it will accept `null`able values.
 * For the JSON variants, it will also accept missing keys.
 */
export const FieldOption: <
  Field extends VariantSchema.Field<any> | Schema.Schema.Any
>(
  self: Field
) => Field extends Schema.Schema.Any
  ? FieldOption<Field>
  : Field extends VariantSchema.Field<infer S>
  ? VariantSchema.Field<{
      readonly [K in keyof S]: S[K] extends Schema.Schema.Any
        ? K extends VariantsDatabase
          ? Schema.OptionFromNullOr<S[K]>
          : Schema.optionalWith<S[K], { as: 'Option'; nullable: true }>
        : never;
    }>
  : never = fieldEvolve({
  get: Schema.OptionFromNullOr,
  add: Schema.OptionFromNullOr,
  update: Schema.OptionFromNullOr,
  json: Schema.optionalWith({ as: 'Option' }),
  jsonAdd: Schema.optionalWith({ as: 'Option', nullable: true }),
  jsonUpdate: Schema.optionalWith({ as: 'Option', nullable: true }),
}) as any;
